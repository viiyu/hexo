title: Use flatbuffers in practice 1 --- WHY
date: 2016-11-27 17:04:34
categories: practice
tags:
	- linux
	- flatbuffers
---
## 开端
我们线上实际运行的一个类似kv store的项目中，服务器与客户端之间的通信使用的是2.4.x的protocol buffers协议。当时在设计时，由于工期或者简便的目的，在数据传输时并没有区分数据字段的类型，而是统一采用了char array的形式。随着业务的发展扩大，现在用户所使用的数据量有了10倍的膨胀，在类型转换和protocol buffers序列化的过程中已经出现了明显性能热点，因此这期项目主要负责对这个热点进行性能优化。

项目初期调研的过程中主要针对一种思路去进行选型：支持具有类型定义的结构化协议。简而言之，就是在每次传输过程中，可以根据传输的数据，来适配相应的数据类型。这一点是protobuffer2.4.x版本中所不具备的。因此最终选择在协议层进行改进。

## 协议对比
主要调研了catnproto、protocol buffers(简称pb)、flatbuffers(简称fb)三种协议。由于catnproto并未找到很出名的工程应用，以及本着对google的信仰，就暂时没有进行深入考量。因此，选型对比主要集中pb2.6以及fb1.3中，主要原因在于其都支持类似Union的类型定义。为什么不用pb3.0，主要还是从稳定性进行考量。

下面是在选型过程中双方的一些对比：
* fb不压缩数据会带来的数据膨胀，根据现有资料，大概会比pb膨胀20%左右，由于服务端使用万兆网卡，网络并不一定会成为瓶颈，但在使用客户端服务器(虚拟机)，这可能是一笔不小的开销，同时由于数据膨胀带来的网络传输消耗，也会对fb反序列化时的优势进行抵消
* fb 需要支持c++11的编译器才能编译，我们项目环境使用非c++11的机器(正在迁移c++11)
* pb 文档更充分，维护性更好

由于网上资料大多含糊不清且跟我们的项目在应用场景上有差异，因此进行了代码对比，整体实现了一个具有Union的Record结构(具体代码可能设计保密协议就不贴了)，使用下来有如下几点比较：
1. pb代码的可读性及使用都要优秀于fb，能够更快的上手及使用，这点可以从测试代码里明显的感受到
2. pb的proto文件编写也更加简洁
    * 简单的说就是fb的union不支持数组，因此具体类型的必须要定义到一个table里去
	    * pb里oneof使用跟其他类型没有什么差别

在效率上，由于fb使用了地址偏移存储的方式，因此可以认为几乎没有序列化及反序列化时间。但是也会因此造成过高的数据膨胀。同时，对比了实际使用时相同数据的写入及读取时间，差别并没有序列化及反序列化那么大。

||size(byte)|serialize(us)|deserialize(us)|total write(us)| total read(us)|
|---|---|---|---|---|---|---|
|pb|1120|60.4|72.181|189.5|193.7|
|fb|1748|7.1|0.076|205.6|94.198|

从上述比较，在实际使用的过程中，我更倾向于选择pb2.6，如果是独立的工程，我也会推荐用pb2.6去实现。但是由于我们系统中已经有了对pb2.4的依赖，且我们依赖的组件也有对pb2.4的依赖，于是，从工程可控性(跨团队交流成本过高)角度考虑，最终选用了依赖较少的fb。



